Log


### Class names
#   2013-12-07
    LabeledShape
        Shape
            LinePartition (dict)        as attribute: line_part; module: rename
                Colineation             as attribute: lines (list)
                    Line
        LPointPartition (dict)          as attribute: lpoint_part; module: rename
            Colabeling                  as attribute: lpoint_specs (set)
                LabeledPoint
                    Point

### ElementCell class
#   2013-12-10
    Analogous methods from SGColumn and SGColabeling:
        __init__()                      __init__()
        collinear()                     colabeled()
        get_maximal_lines_from()        (set.add())
        maximal()                       (set)
        __str__()                       __str__()
        listing()                       listing()
    But this doesn't seem like enough to justify creating a parent class.
    Conclusion: abandon ElementCell.

### Colabeling
#   2013-12-10
    Why implement the collection as a set of lpoint specs
    1.  As a set of LabeledPoint objects. Problem: a set does not use an 
        element's __eq__ method
    2.  As a list of lpoints. Problem: have to implement equivalent methods to
        set methods
    3.  As a set of lpoint specs. Problem: have to unpack and repack lpoints

#   2014-01-06
    Implement __add__()?

#   2014-01-07
    Colabeling. Rename lpoint_list and lpoint_spec_set? #### Yes, do this!

    __init__() should accept the same types as its attributes? Then use factory 
    class methods for other types of arguments. E.g., 
        Colabeling.__init__(self, lpoint_spec_set), not 
        Colabeling.__init__(self, lpoint_list)
    This might reduce the number of conversions. 
    
    LabeledShape.__sub__() alters other. Check __sub__() of subordinate 
    classes. Check other tests

#   2014-01-12
    Invariants / design by contract. Receives / returns / maintains 

#   2014-01-13
    What to do about attribute names that are the same as module names, e.g., 
    LabeledShape.shape?

#   2014-01-15
    LabeledPoint: (label, x, y) instead of (x, y, label)?
    listing with variable decimal places
    
#   2014-01-16
    Shape subtraction problem
    ---v ok
    --h- ok
    --hv ok
    -v-- ok
    -v-v ok
    -vh- ok
    h--- ok
    h--v ok
    h-h- ok
    h-hv ok
    hv-- ok
    hvh- ok
    -vhv not ok [(40, 20, 40, 40), (40, 60, 40, 80), (20, 60, 40, 60)]
    hv-v not ok [(40, 20, 40, 40), (40, 60, 40, 80), (20, 40, 40, 40)]
    hvhv not ok [(40, 20, 40, 40), (40, 60, 40, 80), (20, 40, 40, 40), (20, 60, 40, 60)]
    
    -v-v {(0, 40): []                            }
    -vhv {(0, 40): [],               (90, 60): []}
    hv-v {(0, 40): [], (90, 40): []              }
    hvhv {(0, 40): [], (90, 40): [], (90, 60): []}

#   2014-02-15
    # Listing. Revise to allow a variable number of decimal places. Implemented
    # Point.get_formatted_coord(). 
    # Completed 2014-02-26 
    Invariants.

#   2014-02-19
    Implement value and type checking for arguments. Continue from Colabeling
    
#   2014-02-26
    Rename "protected" methods: method() --> _method()

#   2014-03-01
    Revise error messages: <class name>.<method name>: <message>

#   2014-03-03
    Implement _print_error_message(). Make a parent object with this as a
    method?

#   2014-03-06
    Colabeling. Refactor specs() as an attribute? To complement specs_set. 
    Colabeling.union(). Refactor as __add__() or __or__()?

#   2014-03-07
    Colabeling.get_lpoint_listing(). Shouldn't this be a method of 
    LabeledPoint? Is it relevant that it comes from a spec? 

#   2014-03-09
    LabeledPoint. Allow empty labels? 
    # Implement are_specs(cls). Done 2014-03-10
    